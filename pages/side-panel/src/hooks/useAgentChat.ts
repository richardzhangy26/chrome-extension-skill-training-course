/**
 * æ™ºèƒ½ä½“å¯¹è¯Hook
 * ç®¡ç†å¯¹è¯çŠ¶æ€å’Œå·¥ä½œæµ
 */

import {
  apiRequest,
  extractTrainTaskId,
  getCurrentTabUrl,
  onTabUrlChanged,
  API_ENDPOINTS,
} from '../services/background-bridge';
import { generateStudentAnswer } from '../services/llm-service';
import { agentLogStorage, agentSessionStorage, llmConfigStorage } from '@extension/storage';
import { useState, useCallback, useEffect, useRef } from 'react';
import type { AgentLogEntry } from '@extension/storage';

// ============ ç±»å‹å®šä¹‰ ============
type WorkflowState =
  | 'IDLE'
  | 'FETCHING_STEPS'
  | 'FETCHING_FIRST_STEP'
  | 'RUNNING_CARD'
  | 'CHATTING'
  | 'COMPLETED'
  | 'ERROR';

type MessageRole = 'user' | 'assistant' | 'system';

interface ChatMessage {
  id: string;
  role: MessageRole;
  content: string;
  timestamp: number;
  stepId?: string;
  isAutoGenerated?: boolean;
}

interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// API è¿”å›çš„æ­¥éª¤åˆ—è¡¨é¡¹ç»“æ„ï¼ˆå‚è€ƒ Python: workflow_tester_base.pyï¼‰
interface ScriptStepItem {
  stepId: string; // æ­¥éª¤IDï¼ˆç”¨äº runCardï¼‰
  stepDetailDTO?: {
    stepName?: string;
    stepOrder?: number;
    nodeType?: 'SCRIPT_START' | 'SCRIPT_END' | 'SCRIPT_NODE';
  };
}

// ç”¨äº queryScriptStepFlowList çš„ç»“æ„
interface ScriptStepFlow {
  scriptStepStartId: string;
  scriptStepEndId: string; // ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤çš„ID
  isDefault?: number;
}

interface TrainConfigurationResponse {
  trainTaskName?: string;
}

interface RunCardResponse {
  sessionId: string;
  text?: string; // Python ä»£ç ä¸­ç”¨çš„æ˜¯ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
}

interface ChatResponse {
  text?: string; // Python ä»£ç ä¸­ç”¨çš„æ˜¯ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
  // ç»“æŸåˆ¤æ–­ï¼šå½“ text å’Œ nextStepId éƒ½ä¸º null æ—¶è¡¨ç¤ºå®Œæˆ
}

const TRAINING_DOMAIN = 'hike-teaching-center.polymas.com';

// ============ Hookå®ç° ============
const useAgentChat = () => {
  // çŠ¶æ€
  const [trainTaskId, setTrainTaskId] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [currentStepId, setCurrentStepId] = useState<string | null>(null);
  const [workflowState, setWorkflowState] = useState<WorkflowState>('IDLE');
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dialogueRound, setDialogueRound] = useState(0);
  const [isAutoRunning, setIsAutoRunning] = useState(false);
  const [activeLogSessionId, setActiveLogSessionId] = useState<string | null>(null);

  // ç”¨äºå–æ¶ˆè¯·æ±‚
  const abortControllerRef = useRef<AbortController | null>(null);
  const autoRunActiveRef = useRef(false);
  const autoRunTokenRef = useRef(0);
  const messagesRef = useRef<ChatMessage[]>([]);
  const workflowStateRef = useRef<WorkflowState>('IDLE');
  const isLoadingRef = useRef(false);
  const sessionIdRef = useRef<string | null>(null);
  const currentStepIdRef = useRef<string | null>(null);
  const trainTaskIdRef = useRef<string | null>(null);
  const dialogueRoundRef = useRef(0);
  const activeLogSessionIdRef = useRef<string | null>(null);
  const stepNameMappingRef = useRef<Record<string, string>>({});

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  useEffect(() => {
    workflowStateRef.current = workflowState;
  }, [workflowState]);

  useEffect(() => {
    isLoadingRef.current = isLoading;
  }, [isLoading]);

  useEffect(() => {
    sessionIdRef.current = sessionId;
  }, [sessionId]);

  useEffect(() => {
    currentStepIdRef.current = currentStepId;
  }, [currentStepId]);

  useEffect(() => {
    trainTaskIdRef.current = trainTaskId;
  }, [trainTaskId]);

  useEffect(() => {
    dialogueRoundRef.current = dialogueRound;
  }, [dialogueRound]);

  useEffect(() => {
    activeLogSessionIdRef.current = activeLogSessionId;
  }, [activeLogSessionId]);

  const fetchTrainTaskName = useCallback(async (taskId: string): Promise<string | undefined> => {
    const configResponse = await apiRequest<ApiResponse<TrainConfigurationResponse>>({
      endpoint: API_ENDPOINTS.QUERY_CONFIGURATION,
      method: 'POST',
      body: { trainTaskId: taskId },
    });
    return configResponse?.data?.trainTaskName;
  }, []);
  const updateStoredTrainTaskId = useCallback(async (taskId: string) => {
    try {
      await agentSessionStorage.updateTrainTaskId(taskId);
    } catch (storageError) {
      console.warn('âš ï¸ è®­ç»ƒä»»åŠ¡IDç¼“å­˜å¤±è´¥:', storageError);
    }
  }, []);

  const getStepDisplayName = useCallback((stepId: string) => stepNameMappingRef.current[stepId] ?? stepId, []);
  const resolveCurrentProfileLabel = useCallback(async () => {
    const config = await llmConfigStorage.get();
    const selected = config.studentProfiles.find(profile => profile.id === config.studentProfileId);
    const fallback = config.studentProfiles[0];
    const label = (selected ?? fallback)?.label?.trim();
    return label && label.length > 0 ? label : 'å­¦ç”Ÿ';
  }, []);

  const buildLogSessionName = useCallback((baseName: string, profileLabel: string) => {
    const parts = [baseName, profileLabel, 'å‰§æœ¬'].filter(Boolean);
    return `${parts.join('-')}`;
  }, []);

  // ç”Ÿæˆæ¶ˆæ¯ID
  const generateMessageId = useCallback(() => `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, []);

  // æ·»åŠ æ¶ˆæ¯
  const addMessage = useCallback(
    (role: MessageRole, content: string, isAutoGenerated = false, stepIdOverride?: string) => {
      const message: ChatMessage = {
        id: generateMessageId(),
        role,
        content,
        timestamp: Date.now(),
        stepId: stepIdOverride ?? currentStepId ?? undefined,
        isAutoGenerated,
      };
      setMessages(prev => [...prev, message]);
      return message;
    },
    [generateMessageId, currentStepId],
  );

  const isTerminalStep = useCallback(
    (stepId: string) => getStepDisplayName(stepId) === 'defaultStepName',
    [getStepDisplayName],
  );
  const completeTraining = useCallback(() => {
    setWorkflowState('COMPLETED');
    addMessage('system', 'âœ… æ­å–œï¼è®­ç»ƒå·²å®Œæˆï¼');
  }, [addMessage]);

  const appendLogEntry = useCallback(async (entry: AgentLogEntry) => {
    const sessionId = activeLogSessionIdRef.current;
    if (!sessionId) {
      return;
    }
    await agentLogStorage.addEntry(sessionId, entry);
  }, []);

  const announceNextStep = useCallback(
    (stepId: string) => {
      const stepName = getStepDisplayName(stepId);
      addMessage('system', `è¿›å…¥ä¸‹ä¸€ä¸ªé˜¶æ®µâ€”â€”${stepName}`, false, stepId);
    },
    [addMessage, getStepDisplayName],
  );

  const runCardForStep = useCallback(
    async (stepId: string, sessionOverride?: string | null) => {
      if (!trainTaskId) {
        throw new Error('æœªæ‰¾åˆ°è®­ç»ƒä»»åŠ¡ID');
      }

      setWorkflowState('RUNNING_CARD');

      const runCardResponse = await apiRequest<ApiResponse<RunCardResponse>>({
        endpoint: API_ENDPOINTS.RUN_CARD,
        method: 'POST',
        body: {
          taskId: trainTaskId,
          stepId,
          sessionId: sessionOverride ?? sessionId ?? undefined,
        },
      });

      console.log('ğŸ´ RunCard Response:', JSON.stringify(runCardResponse, null, 2));

      if (!runCardResponse?.data?.sessionId) {
        console.error('âŒ sessionId æœªæ‰¾åˆ°ï¼Œå®Œæ•´å“åº”:', runCardResponse);
        throw new Error('å¯åŠ¨å¯¹è¯å¤±è´¥');
      }

      setSessionId(runCardResponse.data.sessionId);
      sessionIdRef.current = runCardResponse.data.sessionId;
      setCurrentStepId(stepId);
      currentStepIdRef.current = stepId;
      setWorkflowState('CHATTING');

      if (runCardResponse.data.text) {
        addMessage('assistant', runCardResponse.data.text, false, stepId);
        await appendLogEntry({
          type: 'chat',
          timestamp: Date.now(),
          stepId,
          stepName: getStepDisplayName(stepId),
          round: dialogueRoundRef.current,
          source: 'runCard',
          aiText: runCardResponse.data.text,
        });
      }

      if (runCardResponse.data.needSkipStep && runCardResponse.data.nextStepId) {
        const nextStepId = runCardResponse.data.nextStepId;
        setCurrentStepId(nextStepId);
        currentStepIdRef.current = nextStepId;
        announceNextStep(nextStepId);
        if (isTerminalStep(nextStepId)) {
          completeTraining();
          return runCardResponse;
        }
        return runCardForStep(nextStepId, runCardResponse.data.sessionId);
      }

      return runCardResponse;
    },
    [
      trainTaskId,
      sessionId,
      addMessage,
      appendLogEntry,
      getStepDisplayName,
      announceNextStep,
      isTerminalStep,
      completeTraining,
    ],
  );

  // åˆå§‹åŒ– - ä»URLæå–trainTaskId
  const initialize = useCallback(async () => {
    const taskId = await extractTrainTaskId();
    if (taskId) {
      const taskName = await fetchTrainTaskName(taskId);
      setTrainTaskId(taskId);
      await updateStoredTrainTaskId(taskId);
      const displayName = taskName?.trim() || `${taskId.substring(0, 8)}...`;
      addMessage('system', `å·²æ£€æµ‹åˆ°è®­ç»ƒä»»åŠ¡: ${displayName}`);
      return;
    }

    const currentUrl = await getCurrentTabUrl();
    if (!currentUrl?.includes(TRAINING_DOMAIN)) {
      return;
    }

    try {
      const storedSession = await agentSessionStorage.get();
      const storedTaskId = storedSession.trainTaskId?.trim();
      if (storedTaskId) {
        const taskName = await fetchTrainTaskName(storedTaskId);
        setTrainTaskId(storedTaskId);
        const displayName = taskName?.trim() || `${storedTaskId.substring(0, 8)}...`;
        addMessage('system', `å·²ä»ç¼“å­˜æ¢å¤è®­ç»ƒä»»åŠ¡: ${displayName}`);
      }
    } catch (storageError) {
      console.warn('âš ï¸ è¯»å–è®­ç»ƒä»»åŠ¡ç¼“å­˜å¤±è´¥:', storageError);
    }
  }, [addMessage, fetchTrainTaskName, updateStoredTrainTaskId]);

  // ç›‘å¬URLå˜åŒ–
  useEffect(() => {
    initialize();

    const unsubscribe = onTabUrlChanged(async url => {
      if (url.includes('trainTaskId=')) {
        const taskId = await extractTrainTaskId(url);
        if (taskId && taskId !== trainTaskId) {
          const taskName = await fetchTrainTaskName(taskId);
          setTrainTaskId(taskId);
          await updateStoredTrainTaskId(taskId);
          // é‡ç½®çŠ¶æ€
          setSessionId(null);
          setCurrentStepId(null);
          setWorkflowState('IDLE');
          setMessages([]);
          setDialogueRound(0);
          setActiveLogSessionId(null);
          activeLogSessionIdRef.current = null;
          stepNameMappingRef.current = {};
          const displayName = taskName?.trim() || `${taskId.substring(0, 8)}...`;
          addMessage('system', `å·²åˆ‡æ¢åˆ°æ–°ä»»åŠ¡: ${displayName}`);
        }
      }
    });

    return unsubscribe;
  }, [initialize, trainTaskId, addMessage, fetchTrainTaskName, updateStoredTrainTaskId]);

  // å¼€å§‹å¯¹è¯æµç¨‹
  const startConversation = useCallback(async () => {
    if (!trainTaskId) {
      setError('æœªæ‰¾åˆ°è®­ç»ƒä»»åŠ¡IDï¼Œè¯·ç¡®ä¿åœ¨æ­£ç¡®çš„é¡µé¢æ‰“å¼€');
      return;
    }

    setError(null);
    setIsLoading(true);

    try {
      // æ­¥éª¤1: è·å–ä»»åŠ¡é…ç½®ï¼ˆç”¨äºæ—¥å¿—å‘½åï¼‰
      const [taskName, profileLabel] = await Promise.all([
        fetchTrainTaskName(trainTaskId),
        resolveCurrentProfileLabel(),
      ]);
      const displayName = taskName?.trim() || `${trainTaskId.substring(0, 8)}...`;
      const logSessionName = buildLogSessionName(displayName, profileLabel);

      // æ­¥éª¤2: è·å–æ­¥éª¤åˆ—è¡¨
      setWorkflowState('FETCHING_STEPS');
      addMessage('system', 'æ­£åœ¨è·å–è®­ç»ƒæ­¥éª¤...');

      const stepsResponse = await apiRequest<ApiResponse<ScriptStepItem[]>>({
        endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_LIST,
        method: 'POST',
        body: { trainTaskId, trainSubType: 'ability' }, // æ·»åŠ  trainSubType å‚æ•°
      });

      console.log('ğŸ” Steps Response:', JSON.stringify(stepsResponse, null, 2));

      if (!stepsResponse?.data?.length) {
        throw new Error('è·å–æ­¥éª¤åˆ—è¡¨å¤±è´¥');
      }

      const steps = stepsResponse.data;
      console.log('ğŸ“‹ First Step:', JSON.stringify(steps[0], null, 2));

      const stepNameMapping: Record<string, string> = {};
      steps.forEach(step => {
        if (step.stepDetailDTO?.stepName) {
          stepNameMapping[step.stepId] = step.stepDetailDTO.stepName;
        }
      });
      stepNameMappingRef.current = stepNameMapping;

      try {
        const newSession = await agentLogStorage.createSession({
          taskId: trainTaskId,
          taskName: logSessionName,
          stepNameMapping,
        });
        setActiveLogSessionId(newSession.id);
        activeLogSessionIdRef.current = newSession.id;
      } catch (logError) {
        console.warn('âš ï¸ æ—¥å¿—åˆå§‹åŒ–å¤±è´¥:', logError);
      }

      // ä¼˜å…ˆé€šè¿‡ SCRIPT_START + flowList è·å–ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤
      let firstStepId: string | null = null;
      let firstStepName = 'æœªçŸ¥æ­¥éª¤';
      const trainingStartStep =
        steps.slice(0, 2).find(step => step.stepDetailDTO?.nodeType === 'SCRIPT_START') ??
        steps.find(step => step.stepDetailDTO?.nodeType === 'SCRIPT_START');
      const trainingStartStepId = trainingStartStep?.stepId ?? null;

      try {
        const flowResponse = await apiRequest<ApiResponse<ScriptStepFlow[]>>({
          endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_FLOW_LIST,
          method: 'POST',
          body: { trainTaskId },
        });
        console.log('ğŸ”— Flow Response:', JSON.stringify(flowResponse, null, 2));

        if (flowResponse?.data?.length && trainingStartStepId) {
          const matchedFlow =
            flowResponse.data.find(flow => flow.scriptStepStartId === trainingStartStepId && flow.isDefault === 1) ??
            flowResponse.data.find(flow => flow.scriptStepStartId === trainingStartStepId);
          firstStepId = matchedFlow?.scriptStepEndId ?? null;
        }
      } catch {
        console.warn('âš ï¸ flowList è·å–å¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘');
      }

      // å›é€€é€»è¾‘ï¼šå¦‚æœ flowList å¤±è´¥ï¼Œä¼˜å…ˆå–é SCRIPT_START/SCRIPT_END çš„æ­¥éª¤
      if (!firstStepId) {
        const fallbackStep =
          steps.find(step => {
            const nodeType = step.stepDetailDTO?.nodeType;
            return nodeType && nodeType !== 'SCRIPT_START' && nodeType !== 'SCRIPT_END';
          }) ?? steps[steps.length > 2 ? 2 : 0];
        firstStepId = fallbackStep?.stepId ?? null;
      }

      if (!firstStepId) {
        throw new Error('æ— æ³•ç¡®å®šé¦–ä¸ªè®­ç»ƒæ­¥éª¤');
      }

      const matchedStep = steps.find(s => s.stepId === firstStepId);
      if (matchedStep?.stepDetailDTO?.stepName) {
        firstStepName = matchedStep.stepDetailDTO.stepName;
      }

      setCurrentStepId(firstStepId);
      currentStepIdRef.current = firstStepId;

      // æ­¥éª¤2: å¯åŠ¨å¡ç‰‡
      addMessage('system', `æ­£åœ¨å¯åŠ¨æ­¥éª¤: ${firstStepName}...`);

      await runCardForStep(firstStepId);
      setDialogueRound(1);

      addMessage('system', 'å¯¹è¯å·²å¼€å§‹ï¼Œè¯·è¾“å…¥ä½ çš„å›ç­”æˆ–ç‚¹å‡»AIè‡ªåŠ¨å›ç­”');
    } catch (err) {
      setWorkflowState('ERROR');
      setError((err as Error).message);
      addMessage('system', `é”™è¯¯: ${(err as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  }, [trainTaskId, addMessage, runCardForStep, fetchTrainTaskName, resolveCurrentProfileLabel, buildLogSessionName]);

  const stopAutoRun = useCallback(() => {
    if (!autoRunActiveRef.current) {
      return;
    }
    autoRunActiveRef.current = false;
    autoRunTokenRef.current += 1;
    setIsAutoRunning(false);
  }, []);

  // å‘é€ç”¨æˆ·æ¶ˆæ¯
  const sendMessage = useCallback(
    async (content: string) => {
      if (!sessionId || !trainTaskId || !currentStepId || workflowState !== 'CHATTING') {
        return;
      }

      stopAutoRun();
      setIsLoading(true);
      addMessage('user', content, false);

      try {
        // ä¿®å¤ï¼šå‚è€ƒ Python chat() å‡½æ•°ï¼Œéœ€è¦ taskId, stepId, text, sessionId
        const response = await apiRequest<ApiResponse<ChatResponse>>({
          endpoint: API_ENDPOINTS.CHAT,
          method: 'POST',
          body: {
            taskId: trainTaskId, // æ·»åŠ  taskId
            stepId: currentStepId, // æ·»åŠ  stepId
            text: content, // ç”¨ text è€Œä¸æ˜¯ content
            sessionId,
          },
        });

        console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

        const data = response?.data;

        if (data) {
          const nextRound = dialogueRoundRef.current + 1;
          setDialogueRound(prev => prev + 1);
          await appendLogEntry({
            type: 'chat',
            timestamp: Date.now(),
            stepId: currentStepId,
            stepName: getStepDisplayName(currentStepId),
            round: nextRound,
            source: 'chat',
            userText: content,
            aiText: data.text ?? undefined,
          });
        }

        // æ£€æŸ¥è¿”å›ç»“æœï¼Œå¦‚æœ text ä¸º null ä¸” nextStepId ä¸º nullï¼Œä»£è¡¨è¾“å‡ºç»“æŸ
        if (data?.text == null && data?.nextStepId == null) {
          completeTraining();
        } else {
          if (data?.text) {
            addMessage('assistant', data.text);
          }

          // chat è¿”å› nextStepId æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€æ­¥å¹¶è¿è¡Œ runCard
          if (data?.nextStepId) {
            announceNextStep(data.nextStepId);
            if (isTerminalStep(data.nextStepId)) {
              completeTraining();
            } else {
              await runCardForStep(data.nextStepId, sessionId);
            }
          }
        }
      } catch (err) {
        setError((err as Error).message);
        addMessage('system', `å‘é€å¤±è´¥: ${(err as Error).message}`);
      } finally {
        setIsLoading(false);
      }
    },
    [
      sessionId,
      trainTaskId,
      currentStepId,
      workflowState,
      addMessage,
      runCardForStep,
      stopAutoRun,
      appendLogEntry,
      getStepDisplayName,
      announceNextStep,
      isTerminalStep,
      completeTraining,
    ],
  );

  // AIè‡ªåŠ¨ç”Ÿæˆå›ç­”ï¼ˆä½¿ç”¨è±†åŒ…æ¨¡å‹ï¼‰
  const autoGenerate = useCallback(async (): Promise<{ needConfig: boolean }> => {
    const activeSessionId = sessionIdRef.current;
    const activeTrainTaskId = trainTaskIdRef.current;
    const activeStepId = currentStepIdRef.current;
    const activeWorkflowState = workflowStateRef.current;

    if (!activeSessionId || !activeTrainTaskId || !activeStepId || activeWorkflowState !== 'CHATTING') {
      return { needConfig: false };
    }

    const latestMessages = messagesRef.current;
    // è·å–æœ€åä¸€æ¡ AI æ¶ˆæ¯ä½œä¸ºé—®é¢˜
    const lastAssistantMessage = [...latestMessages].reverse().find(m => m.role === 'assistant');
    if (!lastAssistantMessage) {
      addMessage('system', 'æ²¡æœ‰æ‰¾åˆ° AI çš„é—®é¢˜ï¼Œè¯·å…ˆç­‰å¾… AI æé—®');
      return { needConfig: false };
    }

    setIsLoading(true);
    addMessage('system', 'ğŸ¤– æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹ç”Ÿæˆå›ç­”...');

    try {
      // æ„å»ºå¯¹è¯å†å²
      const conversationHistory: Array<{ ai: string; student: string }> = [];
      for (let i = 0; i < latestMessages.length - 1; i++) {
        if (latestMessages[i].role === 'assistant' && latestMessages[i + 1]?.role === 'user') {
          conversationHistory.push({
            ai: latestMessages[i].content,
            student: latestMessages[i + 1].content,
          });
        }
      }

      // è°ƒç”¨ LLM ç”Ÿæˆå›ç­”
      const llmResult = await generateStudentAnswer(lastAssistantMessage.content, conversationHistory);

      // ç§»é™¤"æ­£åœ¨ç”Ÿæˆ"çš„æ¶ˆæ¯
      setMessages(prev => prev.filter(m => !m.content.includes('æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹')));

      if (!llmResult.success) {
        if (llmResult.error?.includes('è¯·å…ˆé…ç½®')) {
          addMessage('system', 'âš ï¸ è¯·å…ˆé…ç½® LLM API Key');
          return { needConfig: true };
        }
        addMessage('system', `âŒ ç”Ÿæˆå¤±è´¥: ${llmResult.error}`);
        return { needConfig: false };
      }

      const generatedAnswer = llmResult.content!;
      console.log('ğŸ¤– LLM ç”Ÿæˆçš„å›ç­”:', generatedAnswer);

      // æ˜¾ç¤ºç”Ÿæˆçš„ç”¨æˆ·å›ç­”
      addMessage('user', generatedAnswer, true, activeStepId);

      // å‘é€å›ç­”åˆ°æœåŠ¡å™¨
      const response = await apiRequest<ApiResponse<ChatResponse>>({
        endpoint: API_ENDPOINTS.CHAT,
        method: 'POST',
        body: {
          taskId: activeTrainTaskId,
          stepId: activeStepId,
          text: generatedAnswer,
          sessionId: activeSessionId,
        },
      });

      console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

      const data = response?.data;

      if (data) {
        const nextRound = dialogueRoundRef.current + 1;
        setDialogueRound(prev => prev + 1);
        await appendLogEntry({
          type: 'chat',
          timestamp: Date.now(),
          stepId: activeStepId,
          stepName: getStepDisplayName(activeStepId),
          round: nextRound,
          source: 'chat',
          userText: generatedAnswer,
          aiText: data.text ?? undefined,
        });
      }

      // æ£€æŸ¥è¿”å›ç»“æœï¼Œå¦‚æœ text ä¸º null ä¸” nextStepId ä¸º nullï¼Œä»£è¡¨è¾“å‡ºç»“æŸ
      if (data?.text == null && data?.nextStepId == null) {
        completeTraining();
      } else {
        if (data?.text) {
          addMessage('assistant', data.text, false, activeStepId);
        }

        // chat è¿”å› nextStepId æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€æ­¥å¹¶è¿è¡Œ runCard
        if (data?.nextStepId) {
          announceNextStep(data.nextStepId);
          if (isTerminalStep(data.nextStepId)) {
            completeTraining();
          } else {
            await runCardForStep(data.nextStepId, activeSessionId);
          }
        }
      }

      return { needConfig: false };
    } catch (err) {
      setError((err as Error).message);
      addMessage('system', `âŒ è‡ªåŠ¨ç”Ÿæˆå¤±è´¥: ${(err as Error).message}`);
      return { needConfig: false };
    } finally {
      setIsLoading(false);
    }
  }, [
    addMessage,
    runCardForStep,
    appendLogEntry,
    getStepDisplayName,
    announceNextStep,
    isTerminalStep,
    completeTraining,
  ]);

  const startAutoRun = useCallback(async (): Promise<{ needConfig: boolean }> => {
    if (autoRunActiveRef.current) {
      return { needConfig: false };
    }

    if (!sessionId || !trainTaskId || !currentStepId) {
      return { needConfig: false };
    }

    autoRunActiveRef.current = true;
    autoRunTokenRef.current += 1;
    const token = autoRunTokenRef.current;
    setIsAutoRunning(true);

    let needConfig = false;

    const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    while (autoRunActiveRef.current && token === autoRunTokenRef.current) {
      const state = workflowStateRef.current;
      if (state === 'COMPLETED' || state === 'ERROR' || state === 'IDLE') {
        break;
      }

      if (state !== 'CHATTING' || isLoadingRef.current) {
        await sleep(300);
        continue;
      }

      const result = await autoGenerate();
      if (result.needConfig) {
        needConfig = true;
        break;
      }

      await sleep(500);
    }

    if (token === autoRunTokenRef.current) {
      autoRunActiveRef.current = false;
    }
    setIsAutoRunning(false);

    return { needConfig };
  }, [autoGenerate, currentStepId, sessionId, trainTaskId]);

  // é‡ç½®å¯¹è¯
  const reset = useCallback(() => {
    abortControllerRef.current?.abort();
    stopAutoRun();
    setSessionId(null);
    setCurrentStepId(null);
    setWorkflowState('IDLE');
    setMessages([]);
    setDialogueRound(0);
    setError(null);
    setIsLoading(false);
    setActiveLogSessionId(null);
    activeLogSessionIdRef.current = null;
    stepNameMappingRef.current = {};
    dialogueRoundRef.current = 0;
  }, [stopAutoRun]);

  return {
    // çŠ¶æ€
    trainTaskId,
    sessionId,
    workflowState,
    messages,
    isLoading,
    error,
    dialogueRound,
    isAutoRunning,

    // æ“ä½œ
    startConversation,
    sendMessage,
    autoGenerate,
    startAutoRun,
    stopAutoRun,
    reset,
    initialize,
  };
};

export { useAgentChat };
export type { WorkflowState, MessageRole, ChatMessage };
