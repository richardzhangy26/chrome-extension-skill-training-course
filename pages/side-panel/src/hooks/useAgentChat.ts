/**
 * æ™ºèƒ½ä½“å¯¹è¯Hook
 * ç®¡ç†å¯¹è¯çŠ¶æ€å’Œå·¥ä½œæµ
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import {
  apiRequest,
  extractTrainTaskId,
  onTabUrlChanged,
  API_ENDPOINTS,
} from '../services/background-bridge';
import { generateStudentAnswer } from '../services/llm-service';

// ============ ç±»å‹å®šä¹‰ ============
export type WorkflowState =
  | 'IDLE'
  | 'FETCHING_STEPS'
  | 'FETCHING_FIRST_STEP'
  | 'RUNNING_CARD'
  | 'CHATTING'
  | 'COMPLETED'
  | 'ERROR';

export type MessageRole = 'user' | 'assistant' | 'system';

export interface ChatMessage {
  id: string;
  role: MessageRole;
  content: string;
  timestamp: number;
  stepId?: string;
  isAutoGenerated?: boolean;
}

interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// API è¿”å›çš„æ­¥éª¤åˆ—è¡¨é¡¹ç»“æ„ï¼ˆå‚è€ƒ Python: workflow_tester_base.pyï¼‰
interface ScriptStepItem {
  stepId: string;  // æ­¥éª¤IDï¼ˆç”¨äº runCardï¼‰
  stepDetailDTO?: {
    stepName?: string;
    stepOrder?: number;
  };
}

// ç”¨äº queryScriptStepFlowList çš„ç»“æ„
interface ScriptStepFlow {
  scriptStepEndId: string;  // ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤çš„ID
}

interface RunCardResponse {
  sessionId: string;
  text?: string;  // Python ä»£ç ä¸­ç”¨çš„æ˜¯ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
}

interface ChatResponse {
  text?: string;  // ä¿®å¤ï¼šç”¨ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
  isCompleted?: boolean;
}

// ============ Hookå®ç° ============
export function useAgentChat() {
  // çŠ¶æ€
  const [trainTaskId, setTrainTaskId] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [currentStepId, setCurrentStepId] = useState<string | null>(null);
  const [workflowState, setWorkflowState] = useState<WorkflowState>('IDLE');
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dialogueRound, setDialogueRound] = useState(0);

  // ç”¨äºå–æ¶ˆè¯·æ±‚
  const abortControllerRef = useRef<AbortController | null>(null);

  // ç”Ÿæˆæ¶ˆæ¯ID
  const generateMessageId = useCallback(() => {
    return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }, []);

  // æ·»åŠ æ¶ˆæ¯
  const addMessage = useCallback(
    (role: MessageRole, content: string, isAutoGenerated = false) => {
      const message: ChatMessage = {
        id: generateMessageId(),
        role,
        content,
        timestamp: Date.now(),
        stepId: currentStepId ?? undefined,
        isAutoGenerated,
      };
      setMessages(prev => [...prev, message]);
      return message;
    },
    [generateMessageId, currentStepId],
  );

  // åˆå§‹åŒ– - ä»URLæå–trainTaskId
  const initialize = useCallback(async () => {
    const taskId = await extractTrainTaskId();
    if (taskId) {
      setTrainTaskId(taskId);
      addMessage('system', `å·²æ£€æµ‹åˆ°è®­ç»ƒä»»åŠ¡: ${taskId.substring(0, 8)}...`);
    }
  }, [addMessage]);

  // ç›‘å¬URLå˜åŒ–
  useEffect(() => {
    initialize();

    const unsubscribe = onTabUrlChanged(async (url) => {
      if (url.includes('trainTaskId=')) {
        const taskId = await extractTrainTaskId(url);
        if (taskId && taskId !== trainTaskId) {
          setTrainTaskId(taskId);
          // é‡ç½®çŠ¶æ€
          setSessionId(null);
          setCurrentStepId(null);
          setWorkflowState('IDLE');
          setMessages([]);
          setDialogueRound(0);
          addMessage('system', `å·²åˆ‡æ¢åˆ°æ–°ä»»åŠ¡: ${taskId.substring(0, 8)}...`);
        }
      }
    });

    return unsubscribe;
  }, [initialize, trainTaskId, addMessage]);

  // å¼€å§‹å¯¹è¯æµç¨‹
  const startConversation = useCallback(async () => {
    if (!trainTaskId) {
      setError('æœªæ‰¾åˆ°è®­ç»ƒä»»åŠ¡IDï¼Œè¯·ç¡®ä¿åœ¨æ­£ç¡®çš„é¡µé¢æ‰“å¼€');
      return;
    }

    setError(null);
    setIsLoading(true);

    try {
      // æ­¥éª¤1: è·å–æ­¥éª¤åˆ—è¡¨
      setWorkflowState('FETCHING_STEPS');
      addMessage('system', 'æ­£åœ¨è·å–è®­ç»ƒæ­¥éª¤...');

      const stepsResponse = await apiRequest<ApiResponse<ScriptStepItem[]>>({
        endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_LIST,
        method: 'POST',
        body: { trainTaskId, trainSubType: 'ability' },  // æ·»åŠ  trainSubType å‚æ•°
      });

      console.log('ğŸ” Steps Response:', JSON.stringify(stepsResponse, null, 2));

      if (!stepsResponse?.data?.length) {
        throw new Error('è·å–æ­¥éª¤åˆ—è¡¨å¤±è´¥');
      }

      const steps = stepsResponse.data;
      console.log('ğŸ“‹ First Step:', JSON.stringify(steps[0], null, 2));

      // ä¼˜å…ˆé€šè¿‡ flowList è·å–ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤ï¼ˆå‚è€ƒ Python: _query_first_step_from_flowï¼‰
      let firstStepId: string | null = null;
      let firstStepName = 'æœªçŸ¥æ­¥éª¤';

      try {
        const flowResponse = await apiRequest<ApiResponse<ScriptStepFlow[]>>({
          endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_FLOW_LIST,
          method: 'POST',
          body: { trainTaskId },
        });
        console.log('ğŸ”— Flow Response:', JSON.stringify(flowResponse, null, 2));

        if (flowResponse?.data?.length) {
          firstStepId = flowResponse.data[0].scriptStepEndId;
        }
      } catch (e) {
        console.warn('âš ï¸ flowList è·å–å¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘');
      }

      // å›é€€é€»è¾‘ï¼šå¦‚æœ flowList å¤±è´¥ï¼Œä½¿ç”¨ stepOrder æ’åºï¼ˆå‚è€ƒ Python ç¬¬ 557-559 è¡Œï¼‰
      if (!firstStepId) {
        // Python ä»£ç : first_idx = 2 if len(data) > 2 else 0
        const firstIdx = steps.length > 2 ? 2 : 0;
        firstStepId = steps[firstIdx].stepId;
      }

      // è·å–æ­¥éª¤åç§°
      const matchedStep = steps.find(s => s.stepId === firstStepId);
      if (matchedStep?.stepDetailDTO?.stepName) {
        firstStepName = matchedStep.stepDetailDTO.stepName;
      }

      setCurrentStepId(firstStepId);

      // æ­¥éª¤2: å¯åŠ¨å¡ç‰‡
      setWorkflowState('RUNNING_CARD');
      addMessage('system', `æ­£åœ¨å¯åŠ¨æ­¥éª¤: ${firstStepName}...`);

      // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ taskId è€Œä¸æ˜¯ trainTaskIdï¼ˆå‚è€ƒ Python: run_card ç¬¬ 575 è¡Œï¼‰
      const runCardResponse = await apiRequest<ApiResponse<RunCardResponse>>({
        endpoint: API_ENDPOINTS.RUN_CARD,
        method: 'POST',
        body: { taskId: trainTaskId, stepId: firstStepId },  // â† ä¿®å¤ï¼štaskId
      });

      console.log('ğŸ´ RunCard Response:', JSON.stringify(runCardResponse, null, 2));

      if (!runCardResponse?.data?.sessionId) {
        console.error('âŒ sessionId æœªæ‰¾åˆ°ï¼Œå®Œæ•´å“åº”:', runCardResponse);
        throw new Error('å¯åŠ¨å¯¹è¯å¤±è´¥');
      }

      setSessionId(runCardResponse.data.sessionId);
      setWorkflowState('CHATTING');
      setDialogueRound(1);

      // æ˜¾ç¤ºAIçš„åˆå§‹æ¶ˆæ¯ï¼ˆPython ä»£ç ç”¨çš„æ˜¯ text å­—æ®µï¼‰
      if (runCardResponse.data.text) {
        addMessage('assistant', runCardResponse.data.text);
      }

      addMessage('system', 'å¯¹è¯å·²å¼€å§‹ï¼Œè¯·è¾“å…¥ä½ çš„å›ç­”æˆ–ç‚¹å‡»AIè‡ªåŠ¨å›ç­”');
    } catch (err) {
      setWorkflowState('ERROR');
      setError((err as Error).message);
      addMessage('system', `é”™è¯¯: ${(err as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  }, [trainTaskId, addMessage]);

  // å‘é€ç”¨æˆ·æ¶ˆæ¯
  const sendMessage = useCallback(
    async (content: string) => {
      if (!sessionId || !trainTaskId || !currentStepId || workflowState !== 'CHATTING') {
        return;
      }

      setIsLoading(true);
      addMessage('user', content, false);

      try {
        // ä¿®å¤ï¼šå‚è€ƒ Python chat() å‡½æ•°ï¼Œéœ€è¦ taskId, stepId, text, sessionId
        const response = await apiRequest<ApiResponse<ChatResponse>>({
          endpoint: API_ENDPOINTS.CHAT,
          method: 'POST',
          body: {
            taskId: trainTaskId,      // æ·»åŠ  taskId
            stepId: currentStepId,    // æ·»åŠ  stepId
            text: content,            // ç”¨ text è€Œä¸æ˜¯ content
            sessionId,
          },
        });

        console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

        if (response?.data?.text) {
          addMessage('assistant', response.data.text);
          setDialogueRound(prev => prev + 1);
        }

        // å¤„ç†æ­¥éª¤è·³è½¬ï¼ˆå‚è€ƒ Python ç¬¬ 656-660 è¡Œï¼‰
        if (response?.data?.needSkipStep && response?.data?.nextStepId) {
          setCurrentStepId(response.data.nextStepId);
          // TODO: å¯èƒ½éœ€è¦è°ƒç”¨ runCard è·å–ä¸‹ä¸€æ­¥çš„ AI æ¶ˆæ¯
        }

        if (response?.data?.isCompleted) {
          setWorkflowState('COMPLETED');
          addMessage('system', 'æ­å–œï¼è®­ç»ƒå·²å®Œæˆï¼');
        }
      } catch (err) {
        setError((err as Error).message);
        addMessage('system', `å‘é€å¤±è´¥: ${(err as Error).message}`);
      } finally {
        setIsLoading(false);
      }
    },
    [sessionId, trainTaskId, currentStepId, workflowState, addMessage],
  );

  // AIè‡ªåŠ¨ç”Ÿæˆå›ç­”ï¼ˆä½¿ç”¨è±†åŒ…æ¨¡å‹ï¼‰
  const autoGenerate = useCallback(async (): Promise<{ needConfig: boolean }> => {
    if (!sessionId || !trainTaskId || !currentStepId || workflowState !== 'CHATTING') {
      return { needConfig: false };
    }

    // è·å–æœ€åä¸€æ¡ AI æ¶ˆæ¯ä½œä¸ºé—®é¢˜
    const lastAssistantMessage = [...messages].reverse().find(m => m.role === 'assistant');
    if (!lastAssistantMessage) {
      addMessage('system', 'æ²¡æœ‰æ‰¾åˆ° AI çš„é—®é¢˜ï¼Œè¯·å…ˆç­‰å¾… AI æé—®');
      return { needConfig: false };
    }

    setIsLoading(true);
    addMessage('system', 'ğŸ¤– æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹ç”Ÿæˆå›ç­”...');

    try {
      // æ„å»ºå¯¹è¯å†å²
      const conversationHistory: Array<{ ai: string; student: string }> = [];
      for (let i = 0; i < messages.length - 1; i++) {
        if (messages[i].role === 'assistant' && messages[i + 1]?.role === 'user') {
          conversationHistory.push({
            ai: messages[i].content,
            student: messages[i + 1].content,
          });
        }
      }

      // è°ƒç”¨ LLM ç”Ÿæˆå›ç­”
      const llmResult = await generateStudentAnswer(lastAssistantMessage.content, conversationHistory);

      // ç§»é™¤"æ­£åœ¨ç”Ÿæˆ"çš„æ¶ˆæ¯
      setMessages(prev => prev.filter(m => !m.content.includes('æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹')));

      if (!llmResult.success) {
        if (llmResult.error?.includes('è¯·å…ˆé…ç½®')) {
          addMessage('system', 'âš ï¸ è¯·å…ˆé…ç½® LLM API Key');
          return { needConfig: true };
        }
        addMessage('system', `âŒ ç”Ÿæˆå¤±è´¥: ${llmResult.error}`);
        return { needConfig: false };
      }

      const generatedAnswer = llmResult.content!;
      console.log('ğŸ¤– LLM ç”Ÿæˆçš„å›ç­”:', generatedAnswer);

      // æ˜¾ç¤ºç”Ÿæˆçš„ç”¨æˆ·å›ç­”
      addMessage('user', generatedAnswer, true);

      // å‘é€å›ç­”åˆ°æœåŠ¡å™¨
      const response = await apiRequest<ApiResponse<ChatResponse>>({
        endpoint: API_ENDPOINTS.CHAT,
        method: 'POST',
        body: {
          taskId: trainTaskId,
          stepId: currentStepId,
          text: generatedAnswer,
          sessionId,
        },
      });

      console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

      if (response?.data?.text) {
        addMessage('assistant', response.data.text);
        setDialogueRound(prev => prev + 1);
      }

      // å¤„ç†æ­¥éª¤è·³è½¬
      if (response?.data?.needSkipStep && response?.data?.nextStepId) {
        setCurrentStepId(response.data.nextStepId);
      }

      if (response?.data?.isCompleted) {
        setWorkflowState('COMPLETED');
        addMessage('system', 'ğŸ‰ æ­å–œï¼è®­ç»ƒå·²å®Œæˆï¼');
      }

      return { needConfig: false };
    } catch (err) {
      setError((err as Error).message);
      addMessage('system', `âŒ è‡ªåŠ¨ç”Ÿæˆå¤±è´¥: ${(err as Error).message}`);
      return { needConfig: false };
    } finally {
      setIsLoading(false);
    }
  }, [sessionId, trainTaskId, currentStepId, workflowState, messages, addMessage]);

  // é‡ç½®å¯¹è¯
  const reset = useCallback(() => {
    abortControllerRef.current?.abort();
    setSessionId(null);
    setCurrentStepId(null);
    setWorkflowState('IDLE');
    setMessages([]);
    setDialogueRound(0);
    setError(null);
    setIsLoading(false);
  }, []);

  return {
    // çŠ¶æ€
    trainTaskId,
    sessionId,
    workflowState,
    messages,
    isLoading,
    error,
    dialogueRound,

    // æ“ä½œ
    startConversation,
    sendMessage,
    autoGenerate,
    reset,
    initialize,
  };
}
