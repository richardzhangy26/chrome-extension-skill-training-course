/**
 * æ™ºèƒ½ä½“å¯¹è¯Hook
 * ç®¡ç†å¯¹è¯çŠ¶æ€å’Œå·¥ä½œæµ
 */

import { apiRequest, extractTrainTaskId, onTabUrlChanged, API_ENDPOINTS } from '../services/background-bridge';
import { generateStudentAnswer } from '../services/llm-service';
import { useState, useCallback, useEffect, useRef } from 'react';

// ============ ç±»å‹å®šä¹‰ ============
type WorkflowState =
  | 'IDLE'
  | 'FETCHING_STEPS'
  | 'FETCHING_FIRST_STEP'
  | 'RUNNING_CARD'
  | 'CHATTING'
  | 'COMPLETED'
  | 'ERROR';

type MessageRole = 'user' | 'assistant' | 'system';

interface ChatMessage {
  id: string;
  role: MessageRole;
  content: string;
  timestamp: number;
  stepId?: string;
  isAutoGenerated?: boolean;
}

interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// API è¿”å›çš„æ­¥éª¤åˆ—è¡¨é¡¹ç»“æ„ï¼ˆå‚è€ƒ Python: workflow_tester_base.pyï¼‰
interface ScriptStepItem {
  stepId: string; // æ­¥éª¤IDï¼ˆç”¨äº runCardï¼‰
  stepDetailDTO?: {
    stepName?: string;
    stepOrder?: number;
  };
}

// ç”¨äº queryScriptStepFlowList çš„ç»“æ„
interface ScriptStepFlow {
  scriptStepEndId: string; // ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤çš„ID
}

interface RunCardResponse {
  sessionId: string;
  text?: string; // Python ä»£ç ä¸­ç”¨çš„æ˜¯ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
}

interface ChatResponse {
  text?: string; // ä¿®å¤ï¼šç”¨ text è€Œä¸æ˜¯ content
  needSkipStep?: boolean;
  nextStepId?: string;
  isCompleted?: boolean;
}

// ============ Hookå®ç° ============
const useAgentChat = () => {
  // çŠ¶æ€
  const [trainTaskId, setTrainTaskId] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [currentStepId, setCurrentStepId] = useState<string | null>(null);
  const [workflowState, setWorkflowState] = useState<WorkflowState>('IDLE');
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dialogueRound, setDialogueRound] = useState(0);
  const [isAutoRunning, setIsAutoRunning] = useState(false);

  // ç”¨äºå–æ¶ˆè¯·æ±‚
  const abortControllerRef = useRef<AbortController | null>(null);
  const autoRunActiveRef = useRef(false);
  const autoRunTokenRef = useRef(0);
  const messagesRef = useRef<ChatMessage[]>([]);
  const workflowStateRef = useRef<WorkflowState>('IDLE');
  const isLoadingRef = useRef(false);

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  useEffect(() => {
    workflowStateRef.current = workflowState;
  }, [workflowState]);

  useEffect(() => {
    isLoadingRef.current = isLoading;
  }, [isLoading]);

  // ç”Ÿæˆæ¶ˆæ¯ID
  const generateMessageId = useCallback(() => `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, []);

  // æ·»åŠ æ¶ˆæ¯
  const addMessage = useCallback(
    (role: MessageRole, content: string, isAutoGenerated = false, stepIdOverride?: string) => {
      const message: ChatMessage = {
        id: generateMessageId(),
        role,
        content,
        timestamp: Date.now(),
        stepId: stepIdOverride ?? currentStepId ?? undefined,
        isAutoGenerated,
      };
      setMessages(prev => [...prev, message]);
      return message;
    },
    [generateMessageId, currentStepId],
  );

  const runCardForStep = useCallback(
    async (stepId: string, sessionOverride?: string | null) => {
      if (!trainTaskId) {
        throw new Error('æœªæ‰¾åˆ°è®­ç»ƒä»»åŠ¡ID');
      }

      setWorkflowState('RUNNING_CARD');

      const runCardResponse = await apiRequest<ApiResponse<RunCardResponse>>({
        endpoint: API_ENDPOINTS.RUN_CARD,
        method: 'POST',
        body: {
          taskId: trainTaskId,
          stepId,
          sessionId: sessionOverride ?? sessionId ?? undefined,
        },
      });

      console.log('ğŸ´ RunCard Response:', JSON.stringify(runCardResponse, null, 2));

      if (!runCardResponse?.data?.sessionId) {
        console.error('âŒ sessionId æœªæ‰¾åˆ°ï¼Œå®Œæ•´å“åº”:', runCardResponse);
        throw new Error('å¯åŠ¨å¯¹è¯å¤±è´¥');
      }

      setSessionId(runCardResponse.data.sessionId);
      setCurrentStepId(stepId);
      setWorkflowState('CHATTING');

      if (runCardResponse.data.text) {
        addMessage('assistant', runCardResponse.data.text, false, stepId);
      }

      if (runCardResponse.data.needSkipStep && runCardResponse.data.nextStepId) {
        setCurrentStepId(runCardResponse.data.nextStepId);
        return runCardForStep(runCardResponse.data.nextStepId, runCardResponse.data.sessionId);
      }

      return runCardResponse;
    },
    [trainTaskId, sessionId, addMessage],
  );

  // åˆå§‹åŒ– - ä»URLæå–trainTaskId
  const initialize = useCallback(async () => {
    const taskId = await extractTrainTaskId();
    if (taskId) {
      setTrainTaskId(taskId);
      addMessage('system', `å·²æ£€æµ‹åˆ°è®­ç»ƒä»»åŠ¡: ${taskId.substring(0, 8)}...`);
    }
  }, [addMessage]);

  // ç›‘å¬URLå˜åŒ–
  useEffect(() => {
    initialize();

    const unsubscribe = onTabUrlChanged(async url => {
      if (url.includes('trainTaskId=')) {
        const taskId = await extractTrainTaskId(url);
        if (taskId && taskId !== trainTaskId) {
          setTrainTaskId(taskId);
          // é‡ç½®çŠ¶æ€
          setSessionId(null);
          setCurrentStepId(null);
          setWorkflowState('IDLE');
          setMessages([]);
          setDialogueRound(0);
          addMessage('system', `å·²åˆ‡æ¢åˆ°æ–°ä»»åŠ¡: ${taskId.substring(0, 8)}...`);
        }
      }
    });

    return unsubscribe;
  }, [initialize, trainTaskId, addMessage]);

  // å¼€å§‹å¯¹è¯æµç¨‹
  const startConversation = useCallback(async () => {
    if (!trainTaskId) {
      setError('æœªæ‰¾åˆ°è®­ç»ƒä»»åŠ¡IDï¼Œè¯·ç¡®ä¿åœ¨æ­£ç¡®çš„é¡µé¢æ‰“å¼€');
      return;
    }

    setError(null);
    setIsLoading(true);

    try {
      // æ­¥éª¤1: è·å–æ­¥éª¤åˆ—è¡¨
      setWorkflowState('FETCHING_STEPS');
      addMessage('system', 'æ­£åœ¨è·å–è®­ç»ƒæ­¥éª¤...');

      const stepsResponse = await apiRequest<ApiResponse<ScriptStepItem[]>>({
        endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_LIST,
        method: 'POST',
        body: { trainTaskId, trainSubType: 'ability' }, // æ·»åŠ  trainSubType å‚æ•°
      });

      console.log('ğŸ” Steps Response:', JSON.stringify(stepsResponse, null, 2));

      if (!stepsResponse?.data?.length) {
        throw new Error('è·å–æ­¥éª¤åˆ—è¡¨å¤±è´¥');
      }

      const steps = stepsResponse.data;
      console.log('ğŸ“‹ First Step:', JSON.stringify(steps[0], null, 2));

      // ä¼˜å…ˆé€šè¿‡ flowList è·å–ç¬¬ä¸€ä¸ªçœŸå®æ­¥éª¤ï¼ˆå‚è€ƒ Python: _query_first_step_from_flowï¼‰
      let firstStepId: string | null = null;
      let firstStepName = 'æœªçŸ¥æ­¥éª¤';

      try {
        const flowResponse = await apiRequest<ApiResponse<ScriptStepFlow[]>>({
          endpoint: API_ENDPOINTS.QUERY_SCRIPT_STEP_FLOW_LIST,
          method: 'POST',
          body: { trainTaskId },
        });
        console.log('ğŸ”— Flow Response:', JSON.stringify(flowResponse, null, 2));

        if (flowResponse?.data?.length) {
          firstStepId = flowResponse.data[0].scriptStepEndId;
        }
      } catch {
        console.warn('âš ï¸ flowList è·å–å¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘');
      }

      // å›é€€é€»è¾‘ï¼šå¦‚æœ flowList å¤±è´¥ï¼Œä½¿ç”¨ stepOrder æ’åºï¼ˆå‚è€ƒ Python ç¬¬ 557-559 è¡Œï¼‰
      if (!firstStepId) {
        // Python ä»£ç : first_idx = 2 if len(data) > 2 else 0
        const firstIdx = steps.length > 2 ? 2 : 0;
        firstStepId = steps[firstIdx].stepId;
      }

      const matchedStep = steps.find(s => s.stepId === firstStepId);
      if (matchedStep?.stepDetailDTO?.stepName) {
        firstStepName = matchedStep.stepDetailDTO.stepName;
      }

      setCurrentStepId(firstStepId);

      // æ­¥éª¤2: å¯åŠ¨å¡ç‰‡
      addMessage('system', `æ­£åœ¨å¯åŠ¨æ­¥éª¤: ${firstStepName}...`);

      await runCardForStep(firstStepId);
      setDialogueRound(1);

      addMessage('system', 'å¯¹è¯å·²å¼€å§‹ï¼Œè¯·è¾“å…¥ä½ çš„å›ç­”æˆ–ç‚¹å‡»AIè‡ªåŠ¨å›ç­”');
    } catch (err) {
      setWorkflowState('ERROR');
      setError((err as Error).message);
      addMessage('system', `é”™è¯¯: ${(err as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  }, [trainTaskId, addMessage, runCardForStep]);

  const stopAutoRun = useCallback(() => {
    if (!autoRunActiveRef.current) {
      return;
    }
    autoRunActiveRef.current = false;
    autoRunTokenRef.current += 1;
    setIsAutoRunning(false);
  }, []);

  // å‘é€ç”¨æˆ·æ¶ˆæ¯
  const sendMessage = useCallback(
    async (content: string) => {
      if (!sessionId || !trainTaskId || !currentStepId || workflowState !== 'CHATTING') {
        return;
      }

      stopAutoRun();
      setIsLoading(true);
      addMessage('user', content, false);

      try {
        // ä¿®å¤ï¼šå‚è€ƒ Python chat() å‡½æ•°ï¼Œéœ€è¦ taskId, stepId, text, sessionId
        const response = await apiRequest<ApiResponse<ChatResponse>>({
          endpoint: API_ENDPOINTS.CHAT,
          method: 'POST',
          body: {
            taskId: trainTaskId, // æ·»åŠ  taskId
            stepId: currentStepId, // æ·»åŠ  stepId
            text: content, // ç”¨ text è€Œä¸æ˜¯ content
            sessionId,
          },
        });

        console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

        if (response?.data?.text) {
          addMessage('assistant', response.data.text);
          setDialogueRound(prev => prev + 1);
        }

        // chat è¿”å› nextStepId æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€æ­¥å¹¶è¿è¡Œ runCard
        if (response?.data?.nextStepId) {
          await runCardForStep(response.data.nextStepId, sessionId);
        }

        if (response?.data?.isCompleted) {
          setWorkflowState('COMPLETED');
          addMessage('system', 'æ­å–œï¼è®­ç»ƒå·²å®Œæˆï¼');
        }
      } catch (err) {
        setError((err as Error).message);
        addMessage('system', `å‘é€å¤±è´¥: ${(err as Error).message}`);
      } finally {
        setIsLoading(false);
      }
    },
    [sessionId, trainTaskId, currentStepId, workflowState, addMessage, runCardForStep, stopAutoRun],
  );

  // AIè‡ªåŠ¨ç”Ÿæˆå›ç­”ï¼ˆä½¿ç”¨è±†åŒ…æ¨¡å‹ï¼‰
  const autoGenerate = useCallback(async (): Promise<{ needConfig: boolean }> => {
    if (!sessionId || !trainTaskId || !currentStepId || workflowState !== 'CHATTING') {
      return { needConfig: false };
    }

    const latestMessages = messagesRef.current;
    // è·å–æœ€åä¸€æ¡ AI æ¶ˆæ¯ä½œä¸ºé—®é¢˜
    const lastAssistantMessage = [...latestMessages].reverse().find(m => m.role === 'assistant');
    if (!lastAssistantMessage) {
      addMessage('system', 'æ²¡æœ‰æ‰¾åˆ° AI çš„é—®é¢˜ï¼Œè¯·å…ˆç­‰å¾… AI æé—®');
      return { needConfig: false };
    }

    setIsLoading(true);
    addMessage('system', 'ğŸ¤– æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹ç”Ÿæˆå›ç­”...');

    try {
      // æ„å»ºå¯¹è¯å†å²
      const conversationHistory: Array<{ ai: string; student: string }> = [];
      for (let i = 0; i < latestMessages.length - 1; i++) {
        if (latestMessages[i].role === 'assistant' && latestMessages[i + 1]?.role === 'user') {
          conversationHistory.push({
            ai: latestMessages[i].content,
            student: latestMessages[i + 1].content,
          });
        }
      }

      // è°ƒç”¨ LLM ç”Ÿæˆå›ç­”
      const llmResult = await generateStudentAnswer(lastAssistantMessage.content, conversationHistory);

      // ç§»é™¤"æ­£åœ¨ç”Ÿæˆ"çš„æ¶ˆæ¯
      setMessages(prev => prev.filter(m => !m.content.includes('æ­£åœ¨ä½¿ç”¨è±†åŒ…æ¨¡å‹')));

      if (!llmResult.success) {
        if (llmResult.error?.includes('è¯·å…ˆé…ç½®')) {
          addMessage('system', 'âš ï¸ è¯·å…ˆé…ç½® LLM API Key');
          return { needConfig: true };
        }
        addMessage('system', `âŒ ç”Ÿæˆå¤±è´¥: ${llmResult.error}`);
        return { needConfig: false };
      }

      const generatedAnswer = llmResult.content!;
      console.log('ğŸ¤– LLM ç”Ÿæˆçš„å›ç­”:', generatedAnswer);

      // æ˜¾ç¤ºç”Ÿæˆçš„ç”¨æˆ·å›ç­”
      addMessage('user', generatedAnswer, true);

      // å‘é€å›ç­”åˆ°æœåŠ¡å™¨
      const response = await apiRequest<ApiResponse<ChatResponse>>({
        endpoint: API_ENDPOINTS.CHAT,
        method: 'POST',
        body: {
          taskId: trainTaskId,
          stepId: currentStepId,
          text: generatedAnswer,
          sessionId,
        },
      });

      console.log('ğŸ’¬ Chat Response:', JSON.stringify(response, null, 2));

      if (response?.data?.text) {
        addMessage('assistant', response.data.text);
        setDialogueRound(prev => prev + 1);
      }

      // chat è¿”å› nextStepId æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€æ­¥å¹¶è¿è¡Œ runCard
      if (response?.data?.nextStepId) {
        await runCardForStep(response.data.nextStepId, sessionId);
      }

      if (response?.data?.isCompleted) {
        setWorkflowState('COMPLETED');
        addMessage('system', 'ğŸ‰ æ­å–œï¼è®­ç»ƒå·²å®Œæˆï¼');
      }

      return { needConfig: false };
    } catch (err) {
      setError((err as Error).message);
      addMessage('system', `âŒ è‡ªåŠ¨ç”Ÿæˆå¤±è´¥: ${(err as Error).message}`);
      return { needConfig: false };
    } finally {
      setIsLoading(false);
    }
  }, [sessionId, trainTaskId, currentStepId, workflowState, addMessage, runCardForStep]);

  const startAutoRun = useCallback(async (): Promise<{ needConfig: boolean }> => {
    if (autoRunActiveRef.current) {
      return { needConfig: false };
    }

    if (!sessionId || !trainTaskId || !currentStepId) {
      return { needConfig: false };
    }

    autoRunActiveRef.current = true;
    autoRunTokenRef.current += 1;
    const token = autoRunTokenRef.current;
    setIsAutoRunning(true);

    let needConfig = false;

    const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    while (autoRunActiveRef.current && token === autoRunTokenRef.current) {
      const state = workflowStateRef.current;
      if (state === 'COMPLETED' || state === 'ERROR' || state === 'IDLE') {
        break;
      }

      if (state !== 'CHATTING' || isLoadingRef.current) {
        await sleep(300);
        continue;
      }

      const result = await autoGenerate();
      if (result.needConfig) {
        needConfig = true;
        break;
      }

      await sleep(500);
    }

    if (token === autoRunTokenRef.current) {
      autoRunActiveRef.current = false;
    }
    setIsAutoRunning(false);

    return { needConfig };
  }, [autoGenerate, currentStepId, sessionId, trainTaskId]);

  // é‡ç½®å¯¹è¯
  const reset = useCallback(() => {
    abortControllerRef.current?.abort();
    stopAutoRun();
    setSessionId(null);
    setCurrentStepId(null);
    setWorkflowState('IDLE');
    setMessages([]);
    setDialogueRound(0);
    setError(null);
    setIsLoading(false);
  }, [stopAutoRun]);

  return {
    // çŠ¶æ€
    trainTaskId,
    sessionId,
    workflowState,
    messages,
    isLoading,
    error,
    dialogueRound,
    isAutoRunning,

    // æ“ä½œ
    startConversation,
    sendMessage,
    autoGenerate,
    startAutoRun,
    stopAutoRun,
    reset,
    initialize,
  };
};

export { useAgentChat };
export type { WorkflowState, MessageRole, ChatMessage };
